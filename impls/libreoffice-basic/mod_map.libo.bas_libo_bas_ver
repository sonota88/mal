rem -*- mode: basic -*-

rem TODO rename: 適切な名前を調べる（他言語版を見る）

Option Explicit

dim log_str as string

type MalMap
  xs() as Variant
  type_ as String
  meta as variant
end type

function new_
  dim rv as New MalMap

  rv.type_ = "MalMap"

  new_ = rv
end function


function size(self)
  dim rv

  if ubound(self.xs) = -1 then
    rv = 0
  else
      dim i, cnt
      i = 0
      do while i <= ubound(self.xs)
          if not _is_deleted(self.xs(i)) then
              cnt = cnt + 1
          end if
          i = i + 2
      loop
      rv = cnt
  end if

  size = rv
end function


function index(self, k)
  'Utils.log1 "-->> MalMap.index()"
  dim rv
  dim i
  
  dim map_key
  map_key = _to_map_key(k)

  dim found_i
  found_i = -1
  for i = 0 to size(self) - 1 ' TODO size を使うとたぶんまずい
    if self.xs(i * 2) = map_key then
      found_i = i
      exit for
    end if
  next

  if 0 <= found_i then
    rv = found_i
  else
    rv = null
  end if

  index = rv
end function


function get_(self, k)
  dim rv

  if size(self) = 0 then
    rv = null
    get_ = rv
    exit function
  end if

  dim i
  i = index(self, k)

  if IsNull(i) then
    'msgbox "67"
    rv = null
  else
    'msgbox "70"
    rv = self.xs(i * 2 + 1)
  end if

  get_ = rv
end function


function has_key(self, k) as Boolean
  'Utils.log1 "-->> MalMap.has_key()"
  dim rv

  dim i
  i = index(self, k)
  rv = not IsNull(i)

  has_key = rv
end function


sub put(self, k, v)
  ' Utils.log2 "-->> MalMap.put()"
  dim found as Boolean
  found = has_key(self, k)
  ' Utils.logkv2 "  -->> MalMap.put() found", found

  if found then
    'Utils.log1 "  104 -->> MalMap.put()"
    dim i
    i = index(self, k)
    self.xs(i * 2 + 1) = v
  else
    'Utils.log1 "  109 -->> MalMap.put()"
    dim work_xs

    dim current_size
    current_size = size(self)

    dim new_ubound
    new_ubound = (current_size * 2) + 1

    work_xs = self.xs
    
    dim map_key
    map_key = _to_map_key(k)
    
    redim preserve work_xs(new_ubound)
    work_xs(new_ubound - 1) = map_key
    work_xs(new_ubound) = v

    self.xs = work_xs
  end if

  dim a
  a = 1
end sub


function get_keys(self)
    on local error goto on_error__MalMap_get_keys

    Utils.log1 "-->> get_keys()"
    Utils.logkv0 "141 self", self
    Utils.logkv0 "141 self.xs", self.xs
    dim rv
    
    dim keys
    keys = List_.new_()
    Utils.logkv0 "143 keys", keys
    
    dim i, key, key_str
    i = 0
    do while i < MalMap.size(self)
        Utils.logkv0 "149 i", i
        Utils.logkv0 "149 xs", self.xs
        ' key = List_.get_(self.xs, i * 2)
        key_str = self.xs(i * 2)
        if not _is_deleted(key_str) then
            key = _from_map_key(key_str)
            List_.add(keys, key)
        end if
        i = i + 1
    loop
    Utils.logkv0 "150 keys", keys
    
    rv = keys
    get_keys = rv

    exit function
on_error__MalMap_get_keys:
    Utils.log0 "---- ERROR ----"
    Utils.logkv0 "self", self
    panic "MalMap.get_keys: " & err & " / L" & erl & " / " & error$
end function



function get_vals(self)
    on local error goto on_error__MalMap_get_vals

    Utils.log1 "-->> get_vals()"
    
    dim rv

    dim _keys
    _keys = get_keys(self)

    dim vals, i, k, v
    vals = List_.new_()
    for i = 0 to List_.size(_keys) - 1
        k = List_.get_(_keys, i)
        if not _is_deleted(k) then ' TODO fix: str key と比較していない
            v = MalMap.get_(self, k)
            List_.add(vals, v)
        end if
    next

    rv = vals
    get_vals = rv

    exit function
on_error__MalMap_get_vals:
    Utils.log0 "---- ERROR ----"
    Utils.logkv0 "self", self
    panic "MalMap.get_vals: " & err & " / L" & erl & " / " & error$
end function



function MalMap_inspect(self)
  dim rv
  
  rv = "{"
  dim i
  ' for i = 0 to MalMap.size(self) - 1
  '     if 1 <= i then
  '         rv = rv & ", "
  '     end if
  '     rv = rv & inspect(self.xs(i * 2))
  '     rv = rv & ": "
  '     rv = rv & inspect(self.xs(i * 2 + 1))
  ' next

  ' 逆順の方がデバッグ時に見やすいので暫定的にこうしている  
  dim size, key
  size = MalMap.size(self)
  for i = 0 to size - 1
      key = self.xs((size - 1 - i) * 2)
      if not _is_deleted(key) then
          if 1 <= i then
              rv = rv & ", "
          end if
          rv = rv & inspect(key)
          rv = rv & ": "
          rv = rv & inspect(self.xs((size - 1 - i) * 2 + 1))
      end if
  next

  rv = rv & "}"
  
  MalMap_inspect = rv
end function


function MalMap_pr_str(self, print_readably as Boolean)
    dim rv

    dim _r
    _r = print_readably

    rv = "{"
    dim i, str_key, count
    count = 0
    for i = 0 to MalMap.size(self) - 1
        str_key = self.xs(i * 2)
        if not _is_deleted(str_key) then
            if 1 <= count then
                rv = rv & " "
            end if

            rv = rv & _pr_str(_from_map_key(str_key), _r)
            rv = rv & " "
            rv = rv & _pr_str(self.xs(i * 2 + 1), _r)
            
            count = count + 1
        end if
    next
    rv = rv & "}"

    MalMap_pr_str = rv
end function


function _to_map_key(val) as String
  'Utils.log1 "-->> MalMap._to_map_key()"
  dim rv
  
  ' Utils.logkv3 "160 type", type_name_ex(val)

  select case type_name_ex(val)
    case "Symbol"
      rv = Symbol_to_map_key(val)
    case "String"
      if Keyword_is_keyword(val) then
          rv = Keyword_to_map_key(val)
      else
          rv = String_to_map_key(val)
      end if
    case "Fname"
      rv = Fname_to_map_key(val)
    case else
      Utils.panic "not_yet_impl"
  end select
    
  _to_map_key = rv
end function


function _from_map_key(key)
    Utils.log1 "-->> _from_map_key()"
    dim rv
    dim str

    if left(key, 4) = "str:" then
        rv = substring(key, 4)
    elseif left(key, 4) = "sym:" then
        str = substring(key, 4)
        rv = Symbol.new_(str)
    elseif left(key, 3) = "kw:" then
        str = substring(key, 3)
        rv = kw_marker() & str
    end if

    _from_map_key = rv
end function


function String_to_map_key(str) as String
  'Utils.log1 "-->> String_to_map_key"
  String_to_map_key = "str:" & str
end function


function Symbol_to_map_key(sym) as String
  'Utils.log1 "-->> Symbol_to_map_key"
  Symbol_to_map_key = "sym:" & sym.str
end function


function Keyword_to_map_key(kw) as String
  'Utils.log1 "-->> Keyword_to_map_key"
  Keyword_to_map_key = "kw:" & substring(kw, 1)
end function


' TODO core からも使っているので、 utils かどこかに移動
function Keyword_is_keyword(kw) as Boolean
    ' Utils.log1 "-->> Keyword_is_keyword"
    dim rv

    if type_name_ex(kw) <> "String" then
        rv = false
        Keyword_is_keyword = rv
        exit function
    end if
    
    rv = (char_at(kw, 0) = kw_marker())

    Keyword_is_keyword = rv
end function


function Fname_to_map_key(fname) as String
  'Utils.log1 "-->> Fname_to_map_key"
  Fname_to_map_key = "fun:" & fname.id
end function


function is_map(val)
    Utils.log1 "-->> is_map()"
    dim rv
    
    rv = type_name_ex(val) = "MalMap"

    is_map = rv
end function


function delete(self, key)
    Utils.log1 "-->> delete()"
    dim rv

    dim str_key
    str_key = _to_map_key(key)

    dim i, k
    do while i <= ubound(self.xs)
        k = self.xs(i)
        if k = str_key then
            self.xs(i) = "DELETED"
            self.xs(i + 1) = null
        end if
        i = i + 2
    loop
    
    rv = null
    delete = rv
end function


function clone(self)
    Utils.log1 "-->> clone()"
    dim rv

    rv = MalMap.new_()
    
    dim keys
    keys = MalMap.get_keys(self)

    dim i as integer
    dim k, v
    for i = 0 to List_.size(keys) - 1
        k = List_.get_(keys, i)
        if not _is_deleted(k) then
            v = MalMap.get_(self, k)
            MalMap.put(rv, k, v)
        end if
    next
    
    clone = rv
end function


function _is_deleted(str_key as String) as Boolean
    _is_deleted = (str_key = "DELETED")
end function
